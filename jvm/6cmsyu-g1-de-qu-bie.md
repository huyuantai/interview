# 1.使用范围不一样
- CMS：老年代
- G1：老年代、新生代

# 2.内存模型不同
- CMS:Eden S1 S2 Old
- G1:以region分区，分区内逻辑分（Eden S1 S2 Old）

#3.STW的时间
- CMS收集器以最小的停顿时间为目标的收集器。
- G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

#4.垃圾碎片 、垃圾算法
- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
- G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

 

# 5.垃圾回收的过程不一样
   CMS收集器                      G1收集器
- 1. 初始标记                   1.初始标记

- 2. 并发标记                   2. 并发标记

- 3. 重新标记                   3. 最终标记

- 4. 并发清除                   4. 筛选回收



G1相比较CMS的改进

 算法： G1基于标记-整理算法, 不会产生空间碎片，分配大对象时不会无法得到连续的空间而提前触发一次FULL GC。
 停顿时间可控： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。
 并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。
3.CMS和G1的区别

 CMS中，堆被分为PermGen，YoungGen，OldGen；而YoungGen又分了两个survivo区域。在G1中，堆被平均分成几个区域(region)，在每个区域中，虽然也保留了新老代的概念，但是收集器是以整个区域为单位收集的。
 G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做。
 G1会在Young GC中使用、而CMS只能在O区使用